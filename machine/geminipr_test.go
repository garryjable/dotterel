package machine

import (
	"errors"
	"testing"

	"github.com/tarm/serial"
)

var expectedGeminiBits = map[string][BytesPerStroke]byte{
	"Fn":   {0xC0, 0x00, 0x00, 0x00, 0x00, 0x00},
	"#1":   {0xA0, 0x00, 0x00, 0x00, 0x00, 0x00},
	"#2":   {0x90, 0x00, 0x00, 0x00, 0x00, 0x00},
	"#3":   {0x88, 0x00, 0x00, 0x00, 0x00, 0x00},
	"#4":   {0x84, 0x00, 0x00, 0x00, 0x00, 0x00},
	"#5":   {0x82, 0x00, 0x00, 0x00, 0x00, 0x00},
	"#6":   {0x81, 0x00, 0x00, 0x00, 0x00, 0x00},
	"S1-":  {0x80, 0x40, 0x00, 0x00, 0x00, 0x00},
	"S2-":  {0x80, 0x20, 0x00, 0x00, 0x00, 0x00},
	"T-":   {0x80, 0x10, 0x00, 0x00, 0x00, 0x00},
	"K-":   {0x80, 0x08, 0x00, 0x00, 0x00, 0x00},
	"P-":   {0x80, 0x04, 0x00, 0x00, 0x00, 0x00},
	"W-":   {0x80, 0x02, 0x00, 0x00, 0x00, 0x00},
	"H-":   {0x80, 0x01, 0x00, 0x00, 0x00, 0x00},
	"R-":   {0x80, 0x00, 0x40, 0x00, 0x00, 0x00},
	"A-":   {0x80, 0x00, 0x20, 0x00, 0x00, 0x00},
	"O-":   {0x80, 0x00, 0x10, 0x00, 0x00, 0x00},
	"*1":   {0x80, 0x00, 0x08, 0x00, 0x00, 0x00},
	"*2":   {0x80, 0x00, 0x04, 0x00, 0x00, 0x00},
	"res1": {0x80, 0x00, 0x02, 0x00, 0x00, 0x00},
	"res2": {0x80, 0x00, 0x01, 0x00, 0x00, 0x00},
	"pwr":  {0x80, 0x00, 0x00, 0x40, 0x00, 0x00},
	"*3":   {0x80, 0x00, 0x00, 0x20, 0x00, 0x00},
	"*4":   {0x80, 0x00, 0x00, 0x10, 0x00, 0x00},
	"-E":   {0x80, 0x00, 0x00, 0x08, 0x00, 0x00},
	"-U":   {0x80, 0x00, 0x00, 0x04, 0x00, 0x00},
	"-F":   {0x80, 0x00, 0x00, 0x02, 0x00, 0x00},
	"-R":   {0x80, 0x00, 0x00, 0x01, 0x00, 0x00},
	"-P":   {0x80, 0x00, 0x00, 0x00, 0x40, 0x00},
	"-B":   {0x80, 0x00, 0x00, 0x00, 0x20, 0x00},
	"-L":   {0x80, 0x00, 0x00, 0x00, 0x10, 0x00},
	"-G":   {0x80, 0x00, 0x00, 0x00, 0x08, 0x00},
	"-T":   {0x80, 0x00, 0x00, 0x00, 0x04, 0x00},
	"-S":   {0x80, 0x00, 0x00, 0x00, 0x02, 0x00},
	"-D":   {0x80, 0x00, 0x00, 0x00, 0x01, 0x00},
	"#7":   {0x80, 0x00, 0x00, 0x00, 0x00, 0x40},
	"#8":   {0x80, 0x00, 0x00, 0x00, 0x00, 0x20},
	"#9":   {0x80, 0x00, 0x00, 0x00, 0x00, 0x10},
	"#A":   {0x80, 0x00, 0x00, 0x00, 0x00, 0x08},
	"#B":   {0x80, 0x00, 0x00, 0x00, 0x00, 0x04},
	"#C":   {0x80, 0x00, 0x00, 0x00, 0x00, 0x02},
	"-Z":   {0x80, 0x00, 0x00, 0x00, 0x00, 0x01},
}

func TestProcessPacket_ValidPacket(t *testing.T) {
	// Tests if the machine can parse a valid cord packet for dictionary entry "doomed"
	called := false
	var received []string

	m := NewGeminiPrMachine("", 0, func(keys []string) {
		called = true
		received = keys
	})

	packet := [BytesPerStroke]byte{0x80, 0x18, 0x30, 0x00, 0x51, 0x00} // T- K- A- O- -P -L -D chord

	expected := []string{"T-", "K-", "A-", "O-", "-P", "-L", "-D"} // spells doomed in steno

	err := m.processPacket(packet)
	if err != nil {
		t.Fatalf("expected no error, got %v", err)
	}
	if !called {
		t.Fatal("callback was not called")
	}
	if len(received) == 0 {
		t.Errorf("expected stroke, got %v", received)
	}

	for i, key := range expected {
		if received[i] != key {
			t.Errorf("expected %s as %d key, got %v", key, i, received[0])
		}
	}
}

func TestGeminiPacketEncoding(t *testing.T) {
	// Tests if the machine can parse a valid cord packet for each individual key on the board
	for expected, packet := range expectedGeminiBits {
		called := false
		var received []string
		m := NewGeminiPrMachine("", 0, func(keys []string) {
			called = true
			received = keys
		})

		err := m.processPacket(packet)
		if err != nil {
			t.Fatalf("expected no error, got %v", err)
		}
		if !called {
			t.Fatal("callback was not called")
		}
		if len(received) == 0 || received[0] != expected {
			t.Errorf("expected T-, got %v", received)
		}
	}
}

func TestProcessPacket_InvalidFirstByte(t *testing.T) {
	// Tests if the machine will error if the MSB of the first byte is not set
	m := NewGeminiPrMachine("", 0, nil)
	packet := [BytesPerStroke]byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x00}
	err := m.processPacket(packet)
	if err == nil || err.Error() != "first byte MSB not set" {
		t.Errorf("expected first byte MSB error, got %v", err)
	}
}

func TestProcessPacket_InvalidOtherByte(t *testing.T) {
	// Tests if the machine will error if the MSB of another byte is set
	m := NewGeminiPrMachine("", 0, nil)
	packet := [BytesPerStroke]byte{0x80, 0x80, 0x00, 0x00, 0x00, 0x00}
	err := m.processPacket(packet)
	if err == nil || !errors.Is(err, err) {
		t.Errorf("expected byte 1 MSB set error, got %v", err)
	}
}

func TestStartStopCapture(t *testing.T) {
	// Tests if machine will error opening a bad serial port
	m := NewGeminiPrMachine("/dev/null", 9600, nil)
	err := m.StartCapture()
	if err == nil {
		t.Error("expected failure on opening /dev/null as serial port")
	}
}

func TestNewGeminiPrMachine(t *testing.T) {
	// Test if machine is created correctly with set values
	m := NewGeminiPrMachine("test", 1234, nil)
	if m == nil {
		t.Fatal("expected machine instance, got nil")
	}
	if m.baudRate != 1234 || m.portName != "test" {
		t.Errorf("unexpected config: %+v", m)
	}
	if m.callback != nil {
		t.Errorf("expected nil callback")
	}
}

func TestReadLoopStops(t *testing.T) {
	// Test if the stop capture function successfully stops the machine.
	m := NewGeminiPrMachine("", 0, nil)
	fakePort := &serial.Port{}
	m.port = fakePort
	go m.StopCapture()
	m.readLoop() // should return quickly
}
